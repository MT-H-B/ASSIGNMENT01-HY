# 10장 유효성 검사와 예외 처리 

##### 유효성 검사 (데이터검증) : 비즈니스 로직이 올바르게 동작하기 위해 데이터를 사전 검증하는 작업 <br/><br/>


## 10.1 일반적인 애플리케이션 유효성 검사의 문제점

* 계층별로 진행하는 유효성 검사는 검증 로직이 각 클래스별로 분산돼 있어 관리가 어려움
* 검증 로직에 중복이 많아 여러 곳에 유사한 기능의 코드가 존재할 수 있음
* 검증해야 할 값이 많다면 검증 코드가 길어짐 &rarr; 코드가 복잡 & 가독성 저하 <br/><br/>

##### ➡️ **Bean Validation** <데이터 유효성 검사 프레임워크> :
#####   어노테이션을 통해 다양한 데이터를 검증하는 기능 제공 <br/><br/>


## 10.2 Hibernate Validator

##### Bean Validation 명세의 구현체
##### 도메인 모델에서 어노테이션을 통한 필드값 검증을 가능하게 도와줌 <br/><br/>


## 10.3 스프링 부트에서의 유효성 검사

### 10.3.1 프로젝트 생성
### 10.3.2 스프링 부트용 유효성 검사 관련 의존성 추가
### 10.3.3 스프링 부트의 유효성 검사
##### 각 계층으로 데이터가 넘어오는 시점에 데이터 검사
##### DTO 객체를 대상으로 수행

* DTO 생성

##### 대표적인 어노테이션
> * 문자열 검증
> * 최댓값/최솟값 검증
> * 값의 범위 검증
> * 시간에 대한 검증
> * 이메일 검증
> * 자릿수 범위 검증
> * Boolean 검증
> * 문자열 길이 검증
> * 정규식 검증

* 컨트롤러 생성 <br/><br/>

### 10.3.4 @Validated 활용
##### <code>\@Valid</code> 자바에서 지원하는 어노테이션
##### <code>\@Validated</code> 스프링에서 지원하는 어노테이션 (<code>\@Valid</code> 가눙 포함)
##### <code>\@Validated</code> 유효성 검사를 그룹으로 묶어 대상 특정 기능

* <code>\@Validated</code> 어노테이션에 특정 그룹을 설정하지 않은 경우
##### &nbsp; &nbsp; &nbsp; &nbsp; groups가 설정되지 않은 필드 유효성 검사
* <code>\@Validated</code> 어노테이션에 특정 그룹을 설장하는 경우
##### &nbsp; &nbsp; &nbsp; &nbsp; 지정된 그룹으로 설정된 필드만 유효성 검사 <br></br>

### 10.3.5 커스텀 Validation 추가
##### 유효성 검사 어노테이션에서 제공하지 않은 기능을 사용할 때,
##### ConstraintValidator와 커스텀 어노테이션을 조합해서 별도의 유효성 검사 어노테이션 생성
##### <code>\@Pattern</code> 어노테이션이 가장 흔한 사례 
##### ➡️ 인터페이스를 선언할 때는 어떤 어노테이션 인터페이스인지 타입 지정 필요 <br></br>

## 10.4 예외 처리
##### 자바에서는 오류를 <code>try/catch, throw</code> 구문을 활용해 처리

### 10.4.1 예외와 에러
* 예외 (Exception)
##### &nbsp; &nbsp; &nbsp; &nbsp; 애플리케이션이 정상적으로 동작하지 못하는 상황
* 에러 (Error)
##### &nbsp; &nbsp; &nbsp; &nbsp; 애플리케이션 코드에서 처리할 수 있는 것이 거의 없음
##### &nbsp; &nbsp; &nbsp; &nbsp; Ex) 메모리 부족, 스택 오버플로 <br></br>

### 10.4.2 예외 클래스
![springboot_pic.png][.\img\springboot_pic.png]
##### 모든 예외 클래스는 Throwable 클래스 상속
##### ✅ Checked Exception
##### &nbsp; &nbsp; &nbsp; 컴파일 단계에서 확인 가능한 예외 상황
##### &nbsp; &nbsp; &nbsp; RuntimeException을 상속 X
##### ✅ Unchecked Exception
##### &nbsp; &nbsp; &nbsp; 문법상 문제는 없지만 프로그램이 동작하는 도중 예기치 않은 상황이 생겨 발생하는 예외
##### &nbsp; &nbsp; &nbsp; RuntimeException을 상속 <br></br>

### 10.4.3 예외 처리 방법
* 예외 복구
##### &nbsp; &nbsp; &nbsp; &nbsp; 예외 상황을 파악해서 문제를 해결하는 방식
##### &nbsp; &nbsp; &nbsp; &nbsp; try / catch
##### ➡️ try : 예외가 발생할 수 있는 코드 작성
##### ➡️ catch : try 블록에서 발생하는 예외 상황 처리 내용 작성
##### &nbsp; &nbsp; &nbsp; catch 블록은 여러 개 작성 가능 <br></br>

* 예외 처리 회피
##### &nbsp; &nbsp; &nbsp; &nbsp; 예외가 발생한 메서드를 호출한 곳에서 에러 처리를 할 수 있게 전가하는 방식
##### &nbsp; &nbsp; &nbsp; &nbsp; throw
##### ➡️ throw : 어떤 예외가 발생했는지 호출부에 내용 전달 <br></br>

* 예외 전환
##### &nbsp; &nbsp; &nbsp; &nbsp; 호출부로 예외 내용을 전달하면서 좀 더 적합한 예외 타입으로 전달
##### &nbsp; &nbsp; &nbsp; &nbsp; try / catch + throw <br></br>

### 10.4.4 스프링 부트의 예외 처리 방식
##### 예외를 복구해서 정상으로 처리하기보다는
##### 요청을 보낸 클라이언트에 어떤 문제가 발생했는지 상황을 전달
##### **Why?** 외부에서 들어오는 요청에 담긴 데이터를 처리하는 경우가 많음
##### ✅ 클라이언트에 오류 메시지를 전달하려면 각 레이어에서 발생한 예외를 엔드포인트 레벨인 컨트롤러로 전달 <br></br>

##### 예외 처리 방식
* @(Rest)ControllerAdvice와 @ExceptionHandler를 통해 모든 컨트롤러의 예외 처리
##### &nbsp; &nbsp; &nbsp; &nbsp; @Controller나 @RestController에서 발생하는 예외를 관리하고 처리할 수 있게 하는 기능
* @ExceptionHandler를 통해 특정 컨트롤러의 예외를 처리
##### &nbsp; &nbsp; &nbsp; &nbsp; @Controller나 @RestController가 적용된 빈에서 발생하는 예외를 잡아 처리하는 메서드를 정의할 때 사용
##### &nbsp; &nbsp; &nbsp; &nbsp; value 속성으로 등록 : 해당 클래스에 국한해서 예외 처리 <br></br>

##### 우선순위
> * 구체적인 클래스가 지정된 쪽
> * 범위가 좁은 컨트롤러의 핸들러 메서드

##### <br></br>

### 10.4.5 커스텀 예외
* 네이밍에 개발자의 의도를 담을 수 있다 ➡️ 이름만으로도 예외 상황 짐작 가능
* 개발자가 예외를 관리하기가 수월
* 예외 상황에 대한 처리 용이

##### <br></br>

### 10.4.6 커스텀 예외 클래스 생성하기
##### 커스텀 예외는 만드는 목적에 따라 생성하는 방법이 다름
##### 커스텀 예외는 예외가 발생하는 상황에 해당하는 상위 예외 클래스를 상속받음